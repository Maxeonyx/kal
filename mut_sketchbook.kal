
// No 1 Most Important
// collecting from iterator
let k = 7;
let primes = fn () { // holds reference to outside context
    yield 2;
    yield k;
};
let mut vals = []; // new context
for n in primes() {
    vals.push(n); // totally fine
}

// GOOD
// mutating list
// doesn't require multiple references to context
let mut list = [0,0,0,0,0,0,0,0,0,0];
for i in 1:10 {
    list[i] = i * i;
}

// OK
// mutating the environment outside if statement
let mut a = 5;
if cond() {
    a = 3;
}

// BAD
// creating a reference cycle with mutable context
let mut var = 5;
let f = fn(x) var = x;
f(f) // f holds a reference to the context containing var, which now holds a reference to f
// its contrived but i think it will happen in practice




// ========================================

// creates reference to heap allocated int.
let mut val = 5;
// MOVES val into obj
let mut obj = { val, };
// error, val is moved.
print(val);


// creates ordinary binding (value not heap allocated)
let val = 5;
// Replaces val binding in scope with a Ref and adds mut binding to obj.
let obj = mut { mut val, }
obj.val += 1;
// fails
print(val);
drop obj;
// succeeds
print(val);


let val = 5;
let obj = { mut val };
obj.val += 1; // fails. obj not mutable, even though val is. This is valid but wierd.
let obj = mut { val };
obj.val += 1; // fails. val not mutable.
