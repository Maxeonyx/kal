use crate::ast::*;
use std::collections::HashMap;
use std::str::FromStr;

grammar;

// Macro for making comma-separated lists of anything
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        },
    },
};

Block: Block = {
	"{" <b:BlockInnerNotEmpty> "}" => b,
};

// kal files are "block inners".
// Essentially they are zero parameter functions
// We explicitly allow empty files.
pub BlockInner: Block = {
    =>
        Block {
            statements: Vec::new(),
            expression: None,
        },
    <e:Expression> =>
        Block {
            statements: Vec::new(),
            expression: Some(Box::new(e)),
        },
    <v:(<Statement> ";")+> <e:Expression?> =>
        Block {
            statements: v,
            expression: e.map(|expr| Box::new(expr)),
        },
}

// Blocks do not allow the block to be empty. This means that lone curly braces are empty objects instead.
pub BlockInnerNotEmpty: Block = {
    <e:Expression> =>
        Block {
            statements: Vec::new(),
            expression: Some(Box::new(e)),
        },
    <v:(<Statement> ";")+> <e:Expression?> => {
        Block {
            statements: v,
            expression: e.map(|expr| Box::new(expr)),
        }
    }
}

Statement: Statement = {
    <le:LetStatement> => Statement::Let(le),
}

// Function literal is highest operator precedence.
Expression: Expression = {
    <fl:FunctionLiteral> => Expression::Literal(Literal::Function(fl)),
    BooleanExpression,
}

BooleanExpression: Expression = {
    <l:BooleanExpression> <o:BooleanOperator> <r:ComparisonExpression> =>
        Expression::Boolean(BooleanExpression {
            left: Box::new(l),
            right: Box::new(r),
            operator: o,
        }),
    NotExpression,
}

BooleanOperator: BooleanOperator = {
    "and" => BooleanOperator::And,
    "or" => BooleanOperator::Or,
    "xor" => BooleanOperator::Xor,
}

NotExpression: Expression = {
    "not" <e:NotExpression> =>
        Expression::Not(NotExpression {
            expr: Box::new(e),
        }),
    ComparisonExpression,
}

ComparisonExpression: Expression = {
    <l:ComparisonExpression> <o:ComparisonOperator> <r:AddExpression> =>
    Expression::Comparison(ComparisonExpression {
        left: Box::new(l),
        right: Box::new(r),
        operator: o,
    }),
    AddExpression,
}

ComparisonOperator: ComparisonOperator = {
    "==" => ComparisonOperator::Equal,
    "!=" => ComparisonOperator::NotEqual,
    "<=" => ComparisonOperator::LessEqual,
    "<" => ComparisonOperator::Less,
    ">=" => ComparisonOperator::GreaterEqual,
    ">" => ComparisonOperator::Greater,
}

AddExpression: Expression = {
    <l:AddExpression> "+" <r:MultiplyExpression> =>
        Expression::Numeric(NumericExpression {
            left: Box::new(l),
            right: Box::new(r),
            operator: NumericOperator::Add,
        }),
    <l:AddExpression> "-" <r:MultiplyExpression> =>
        Expression::Numeric(NumericExpression {
            left: Box::new(l),
            right: Box::new(r),
            operator: NumericOperator::Subtract,
        }),
    MultiplyExpression,
}

MultiplyExpression: Expression = {
    <l:MultiplyExpression> "*" <r:NormalExpression> =>
        Expression::Numeric(NumericExpression {
            left: Box::new(l),
            right: Box::new(r),
            operator: NumericOperator::Multiply,
        }),
    <l:MultiplyExpression> "/" <r:NormalExpression> =>
        Expression::Numeric(NumericExpression {
            left: Box::new(l),
            right: Box::new(r),
            operator: NumericOperator::Divide,
        }),
    NegativeExpression,
}

NegativeExpression: Expression = {
    "-" <e:NormalExpression> =>
        Expression::Negative(NegativeExpression {
            expr: Box::new(e),
        }),
    NormalExpression,
}

NormalExpression: Expression = {
    <l:Literal> => Expression::Literal(l),
    <ie:IfExpression> => Expression::If(ie),
    SimpleExpression,
}

SimpleExpression: Expression = {
    <i:Ident> => Expression::Ident(i),
    <fi:FunctionInvocation> => Expression::FunctionInvocation(fi),
    <de:DotExpression> => Expression::Dot(de),
    <ie:IndexExpression> => Expression::Index(ie),
    <pe:ParenExpression> => pe,
}

DotExpression: DotExpression = {
    <se:SimpleExpression> "." <i:Ident> =>
        DotExpression {
            base: Box::new(se),
            prop: i,
        },
}

IndexExpression: IndexExpression = {
    <base:SimpleExpression> "[" <index:Expression> "]" =>
        IndexExpression {
            base: Box::new(base),
            index: Box::new(index),
        },
}

ParenExpression: Expression = {
    "(" <e:Expression> ")" => e,
}

FunctionLiteral: Function = {
    "fn" "(" <p:Comma<Ident>> ")" <b:FunctionBody> =>
    Function {
        parameters: p,
        body: b,
    },
}

FunctionBody: Block = {
    <e: Expression> => Block {
        statements: Vec::new(),
        expression: Some(Box::new(e)),
    },
    <b: Block> => b,
}

LetStatement: LetStatement = {
    "let" <i:Ident> "=" <e:Expression> =>
    LetStatement {
        variable: i,
        expr: Box::new(e),
    },
}

IfExpression: IfExpression = {
    "if" <c:Expression> <b:Block> <eb:ElseBody?> =>

    IfExpression {
        cond: Box::new(c),
        body: b,
        else_body: eb
    },
}

ElseBody: Block = {
    "else" <b:Block> => b,
}

FunctionInvocation: FunctionInvocation = {
    <se:SimpleExpression> "(" <v:Comma<Expression>> ")" =>

    FunctionInvocation {
        closure_expression: Box::new(se),
        parameters: v,
    },
}

Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "symbol" => Literal::Symbol,
    <n:Int> => Literal::Int(n),
    //<s:Str> => Literal::String(s),
    <l:List> => Literal::List(l),
    <o:Object> => Literal::Object(o),
}

List: ListLiteral = {
    "[" <v:Comma<Expression>> "]" =>

    ListLiteral {
        elements: v,
    },
}

Object: ObjectLiteral = {
    "{" <v:Comma<ObjectKV>> "}" =>

    {
        let mut h = HashMap::new();
        for (i, e) in v {
            h.insert(i, e);
        }

        ObjectLiteral {
            map: h,
        }
    },
}

ObjectKV: (Ident, Expression) = {
    <i:Ident> ":" <e:Expression> => (i, e),
}

Ident: Ident = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> =>

    Ident {
        name: s.to_owned(),
    },
}

Int: i64 = {
    // `unwrap` todo convert to fallible operation (e.g. Int or TooLong)
    <i:r"0|(?:[1-9][0-9]*)"> => i64::from_str(<>).unwrap(),
}
